<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIå¹³æ¿å¹³è¡¡è®­ç»ƒæ¼”ç¤º</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .main-content {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .simulation-area {
            flex: 2;
            text-align: center;
        }

        .controls-area {
            flex: 1;
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
        }

        #gameCanvas {
            border: 3px solid #4a5568;
            border-radius: 10px;
            background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 100%);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .controls h3 {
            color: #4a5568;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 100px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        .metrics {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px solid #cbd5e0;
        }

        .metric-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .metric-label {
            font-weight: bold;
            color: #4a5568;
        }

        .metric-value {
            color: #667eea;
            font-family: 'Courier New', monospace;
        }

        .training-progress {
            background: #e6fffa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #38b2ac;
        }

        .progress-bar {
            background: #cbd5e0;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            background: linear-gradient(90deg, #38b2ac, #4fd1c7);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .description {
            background: #fffaf0;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #ed8936;
        }

        .description h3 {
            color: #c05621;
            margin-top: 0;
        }

        .status {
            text-align: center;
            padding: 10px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: bold;
        }

        .status.training {
            background: #fed7d7;
            color: #c53030;
        }

        .status.converged {
            background: #c6f6d5;
            color: #22543d;
        }

        .status.idle {
            background: #e2e8f0;
            color: #4a5568;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– AIå¹³æ¿å¹³è¡¡è®­ç»ƒæ¼”ç¤º</h1>
        
        <div class="description">
            <h3>ğŸ¯ è®­ç»ƒç›®æ ‡</h3>
            <p>AIéœ€è¦å­¦ä¼šæ§åˆ¶å¹³æ¿çš„æ—‹è½¬ï¼Œä½¿éšæœºåˆå§‹ä½ç½®å’Œé€Ÿåº¦çš„å°çƒç¨³å®šåœ¨å¹³æ¿ä¸­å¿ƒã€‚AIå¯ä»¥è·å¾—å°çƒä½ç½®ã€é€Ÿåº¦å’Œå¹³æ¿è§’åº¦ä¿¡æ¯ï¼Œé€šè¿‡é¡ºæ—¶é’ˆæˆ–é€†æ—¶é’ˆæ—‹è½¬å¹³æ¿æ¥å®ç°å¹³è¡¡æ§åˆ¶ã€‚</p>
        </div>

        <div class="main-content">
            <div class="simulation-area">
                <canvas id="gameCanvas" width="600" height="400"></canvas>
                <div id="status" class="status idle">ğŸ”„ å‡†å¤‡å°±ç»ª</div>
            </div>

            <div class="controls-area">
                <div class="controls">
                    <h3>ğŸ® æ§åˆ¶é¢æ¿</h3>
                    <div class="button-group">
                        <button id="startBtn">å¼€å§‹è®­ç»ƒ</button>
                        <button id="resetBtn">é‡ç½®</button>
                    </div>
                    <div class="button-group">
                        <button id="pauseBtn" disabled>æš‚åœ</button>
                        <button id="stepBtn" disabled>å•æ­¥æ‰§è¡Œ</button>
                    </div>
                </div>

                <div class="metrics">
                    <h3>ğŸ“Š å®æ—¶æ•°æ®</h3>
                    <div class="metric-item">
                        <span class="metric-label">å°çƒä½ç½®:</span>
                        <span class="metric-value" id="ballPos">0.00</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">å°çƒé€Ÿåº¦:</span>
                        <span class="metric-value" id="ballVel">0.00</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">å¹³æ¿è§’åº¦:</span>
                        <span class="metric-value" id="plateAngle">0.00Â°</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">AIåŠ¨ä½œ:</span>
                        <span class="metric-value" id="aiAction">å¾…æœº</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">å¥–åŠ±å€¼:</span>
                        <span class="metric-value" id="reward">0.00</span>
                    </div>
                </div>

                <div class="training-progress">
                    <h3>ğŸ§  è®­ç»ƒè¿›åº¦</h3>
                    <div class="metric-item">
                        <span class="metric-label">è®­ç»ƒè½®æ¬¡:</span>
                        <span class="metric-value" id="episode">0</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">æˆåŠŸç‡:</span>
                        <span class="metric-value" id="successRate">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">å¹³å‡å¥–åŠ±:</span>
                        <span class="metric-value" id="avgReward">0.00</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        class GameState {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.isRunning = false;
                this.isPaused = false;
                
                // ç‰©ç†å‚æ•°
                this.gravity = 0.5;
                this.platformLength = 300;
                this.platformY = 300;
                this.centerX = this.canvas.width / 2;
                
                // å¹³æ¿çŠ¶æ€
                this.plateAngle = 0; // å¼§åº¦
                this.plateAngularVelocity = 0;
                
                // å°çƒçŠ¶æ€
                this.ballX = 0; // ç›¸å¯¹å¹³æ¿ä¸­å¿ƒçš„ä½ç½®
                this.ballVelX = 0; // ç›¸å¯¹å¹³æ¿çš„é€Ÿåº¦
                this.ballY = 0; // å°çƒç¦»å¹³æ¿çš„é«˜åº¦
                this.ballVelY = 0;
                
                // AIçŠ¶æ€
                this.ai = new BalanceAI();
                this.episode = 0;
                this.stepCount = 0;
                this.maxStepsPerEpisode = 1000;
                this.totalReward = 0;
                this.episodeRewards = [];
                this.successCount = 0;
                
                this.reset();
                this.setupEventListeners();
                this.updateDisplay();
                this.draw();
            }
            
            reset() {
                // éšæœºåˆå§‹åŒ–å°çƒä½ç½®å’Œé€Ÿåº¦
                this.ballX = (Math.random() - 0.5) * 200; // -100 åˆ° 100
                this.ballVelX = (Math.random() - 0.5) * 10; // -5 åˆ° 5
                this.ballY = 0;
                this.ballVelY = 0;
                
                // é‡ç½®å¹³æ¿
                this.plateAngle = (Math.random() - 0.5) * 0.5; // å°è§’åº¦éšæœº
                this.plateAngularVelocity = 0;
                
                // é‡ç½®è®¡æ•°å™¨
                this.stepCount = 0;
                this.totalReward = 0;
            }
            
            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.start();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.stop();
                    this.reset();
                    this.episode = 0;
                    this.episodeRewards = [];
                    this.successCount = 0;
                    this.ai.reset();
                    this.updateDisplay();
                    this.draw();
                });
                
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.togglePause();
                });
                
                document.getElementById('stepBtn').addEventListener('click', () => {
                    if (this.isPaused) {
                        this.step();
                    }
                });
            }
            
            start() {
                this.isRunning = true;
                this.isPaused = false;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('stepBtn').disabled = false;
                this.updateStatus('training', 'ğŸ¤– AIæ­£åœ¨è®­ç»ƒä¸­...');
                this.gameLoop();
            }
            
            stop() {
                this.isRunning = false;
                this.isPaused = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('stepBtn').disabled = true;
                this.updateStatus('idle', 'ğŸ”„ å‡†å¤‡å°±ç»ª');
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                document.getElementById('pauseBtn').textContent = this.isPaused ? 'ç»§ç»­' : 'æš‚åœ';
                this.updateStatus(this.isPaused ? 'idle' : 'training', 
                                this.isPaused ? 'â¸ï¸ å·²æš‚åœ' : 'ğŸ¤– AIæ­£åœ¨è®­ç»ƒä¸­...');
                if (!this.isPaused) {
                    this.gameLoop();
                }
            }
            
            updateStatus(className, text) {
                const status = document.getElementById('status');
                status.className = `status ${className}`;
                status.textContent = text;
            }
            
            step() {
                // è·å–å½“å‰çŠ¶æ€
                const state = this.getState();
                
                // AIå†³ç­–
                const action = this.ai.getAction(state);
                
                // æ‰§è¡ŒåŠ¨ä½œ
                this.executeAction(action);
                
                // ç‰©ç†æ›´æ–°
                this.updatePhysics();
                
                // è®¡ç®—å¥–åŠ±
                const reward = this.calculateReward();
                this.totalReward += reward;
                
                // AIå­¦ä¹ 
                const nextState = this.getState();
                this.ai.learn(state, action, reward, nextState, this.isEpisodeEnd());
                
                this.stepCount++;
                
                // æ£€æŸ¥episodeç»“æŸæ¡ä»¶
                if (this.isEpisodeEnd()) {
                    this.endEpisode();
                }
                
                this.updateDisplay();
                this.draw();
            }
            
            gameLoop() {
                if (!this.isRunning || this.isPaused) return;
                
                this.step();
                
                // ç»§ç»­å¾ªç¯
                if (this.isRunning) {
                    setTimeout(() => this.gameLoop(), 50); // 20 FPS
                }
            }
            
            getState() {
                return {
                    ballPosition: this.ballX / 150, // å½’ä¸€åŒ–
                    ballVelocity: this.ballVelX / 10, // å½’ä¸€åŒ–
                    plateAngle: this.plateAngle / (Math.PI / 4), // å½’ä¸€åŒ–
                    plateAngularVelocity: this.plateAngularVelocity / 0.1 // å½’ä¸€åŒ–
                };
            }
            
            executeAction(action) {
                const torque = 0.002; // æ‰­çŸ©å¼ºåº¦
                if (action === 1) { // é¡ºæ—¶é’ˆ
                    this.plateAngularVelocity += torque;
                } else if (action === -1) { // é€†æ—¶é’ˆ
                    this.plateAngularVelocity -= torque;
                }
                // action === 0 ä¸åŠ¨ä½œ
                
                // é™åˆ¶è§’é€Ÿåº¦
                this.plateAngularVelocity = Math.max(-0.1, Math.min(0.1, this.plateAngularVelocity));
                
                // æ›´æ–°è§’åº¦
                this.plateAngle += this.plateAngularVelocity;
                
                // é™åˆ¶è§’åº¦
                this.plateAngle = Math.max(-Math.PI/3, Math.min(Math.PI/3, this.plateAngle));
                
                // æ·»åŠ é˜»å°¼
                this.plateAngularVelocity *= 0.95;
            }
            
            updatePhysics() {
                // è®¡ç®—å¹³æ¿ä¸Šçš„é‡åŠ›åˆ†é‡
                const gravityComponent = this.gravity * Math.sin(this.plateAngle);
                
                // æ›´æ–°å°çƒé€Ÿåº¦ï¼ˆå—é‡åŠ›å½±å“ï¼‰
                this.ballVelX += gravityComponent;
                
                // æ›´æ–°å°çƒä½ç½®
                this.ballX += this.ballVelX;
                
                // æ·»åŠ ç©ºæ°”é˜»åŠ›
                this.ballVelX *= 0.995;
                
                // è¾¹ç•Œæ£€æŸ¥
                const maxPos = this.platformLength / 2;
                if (Math.abs(this.ballX) > maxPos) {
                    this.ballX = Math.sign(this.ballX) * maxPos;
                    this.ballVelX = -this.ballVelX * 0.5; // åå¼¹å¹¶æŸå¤±èƒ½é‡
                }
            }
            
            calculateReward() {
                const positionError = Math.abs(this.ballX);
                const velocityError = Math.abs(this.ballVelX);
                const angleError = Math.abs(this.plateAngle);
                
                // è·ç¦»ä¸­å¿ƒè¶Šè¿‘ï¼Œé€Ÿåº¦è¶Šå°ï¼Œè§’åº¦è¶Šå°ï¼Œå¥–åŠ±è¶Šé«˜
                const positionReward = Math.max(0, 1 - positionError / 150);
                const velocityReward = Math.max(0, 1 - velocityError / 5);
                const angleReward = Math.max(0, 1 - angleError / (Math.PI / 4));
                
                // ç»„åˆå¥–åŠ±
                let reward = positionReward * 0.5 + velocityReward * 0.3 + angleReward * 0.2;
                
                // å¦‚æœå°çƒåœ¨ä¸­å¿ƒé™„è¿‘ä¸”å‡ ä¹é™æ­¢ï¼Œç»™äºˆé¢å¤–å¥–åŠ±
                if (positionError < 20 && velocityError < 1) {
                    reward += 2;
                }
                
                // å¦‚æœå°çƒæ‰è½æˆ–è§’åº¦è¿‡å¤§ï¼Œç»™äºˆæƒ©ç½š
                if (Math.abs(this.ballX) > this.platformLength / 2 - 10) {
                    reward -= 5;
                }
                
                return reward;
            }
            
            isEpisodeEnd() {
                return this.stepCount >= this.maxStepsPerEpisode || 
                       Math.abs(this.ballX) > this.platformLength / 2 ||
                       (Math.abs(this.ballX) < 20 && Math.abs(this.ballVelX) < 0.5 && this.stepCount > 100);
            }
            
            endEpisode() {
                this.episode++;
                this.episodeRewards.push(this.totalReward);
                
                // æ£€æŸ¥æ˜¯å¦æˆåŠŸï¼ˆå°çƒç¨³å®šåœ¨ä¸­å¿ƒï¼‰
                if (Math.abs(this.ballX) < 20 && Math.abs(this.ballVelX) < 0.5) {
                    this.successCount++;
                }
                
                // å¦‚æœAIå·²ç»æ”¶æ•›ï¼Œæ˜¾ç¤ºæˆåŠŸçŠ¶æ€
                if (this.episodeRewards.length >= 10) {
                    const recentAvg = this.episodeRewards.slice(-10).reduce((a, b) => a + b) / 10;
                    if (recentAvg > 50 && this.getSuccessRate() > 0.7) {
                        this.updateStatus('converged', 'ğŸ‰ AIå·²æˆåŠŸå­¦ä¼šå¹³è¡¡ï¼');
                    }
                }
                
                this.reset();
            }
            
            getSuccessRate() {
                if (this.episode === 0) return 0;
                return this.successCount / this.episode;
            }
            
            getAverageReward() {
                if (this.episodeRewards.length === 0) return 0;
                const recent = Math.min(10, this.episodeRewards.length);
                return this.episodeRewards.slice(-recent).reduce((a, b) => a + b) / recent;
            }
            
            updateDisplay() {
                document.getElementById('ballPos').textContent = this.ballX.toFixed(2);
                document.getElementById('ballVel').textContent = this.ballVelX.toFixed(2);
                document.getElementById('plateAngle').textContent = (this.plateAngle * 180 / Math.PI).toFixed(1) + 'Â°';
                
                const action = this.ai.lastAction;
                let actionText = 'å¾…æœº';
                if (action === 1) actionText = 'é¡ºæ—¶é’ˆ â†»';
                else if (action === -1) actionText = 'é€†æ—¶é’ˆ â†º';
                else if (action === 0) actionText = 'ä¿æŒ â—';
                document.getElementById('aiAction').textContent = actionText;
                
                document.getElementById('reward').textContent = this.totalReward.toFixed(2);
                document.getElementById('episode').textContent = this.episode.toString();
                document.getElementById('successRate').textContent = (this.getSuccessRate() * 100).toFixed(1) + '%';
                document.getElementById('avgReward').textContent = this.getAverageReward().toFixed(2);
                
                // æ›´æ–°è¿›åº¦æ¡
                const progress = Math.min(100, this.getSuccessRate() * 100);
                document.getElementById('progressFill').style.width = progress + '%';
            }
            
            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
                this.drawGrid();
                
                // ç»˜åˆ¶æ”¯ç‚¹
                ctx.fillStyle = '#4a5568';
                ctx.beginPath();
                ctx.arc(this.centerX, this.platformY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶å¹³æ¿
                this.drawPlatform();
                
                // ç»˜åˆ¶å°çƒ
                this.drawBall();
                
                // ç»˜åˆ¶ç›®æ ‡åŒºåŸŸ
                this.drawTarget();
            }
            
            drawGrid() {
                const ctx = this.ctx;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                
                // å‚ç›´çº¿
                for (let x = 0; x < this.canvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.canvas.height);
                    ctx.stroke();
                }
                
                // æ°´å¹³çº¿
                for (let y = 0; y < this.canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.canvas.width, y);
                    ctx.stroke();
                }
            }
            
            drawPlatform() {
                const ctx = this.ctx;
                const halfLength = this.platformLength / 2;
                
                // è®¡ç®—å¹³æ¿ç«¯ç‚¹
                const cos = Math.cos(this.plateAngle);
                const sin = Math.sin(this.plateAngle);
                
                const x1 = this.centerX - halfLength * cos;
                const y1 = this.platformY - halfLength * sin;
                const x2 = this.centerX + halfLength * cos;
                const y2 = this.platformY + halfLength * sin;
                
                // ç»˜åˆ¶å¹³æ¿
                ctx.strokeStyle = '#2d3748';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // ç»˜åˆ¶å¹³æ¿ç«¯ç‚¹
                ctx.fillStyle = '#e53e3e';
                ctx.beginPath();
                ctx.arc(x1, y1, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x2, y2, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawBall() {
                const ctx = this.ctx;
                
                // è®¡ç®—å°çƒåœ¨å±å¹•ä¸Šçš„ä½ç½®
                const cos = Math.cos(this.plateAngle);
                const sin = Math.sin(this.plateAngle);
                
                const ballScreenX = this.centerX + this.ballX * cos;
                const ballScreenY = this.platformY + this.ballX * sin - 15; // å°çƒåœ¨å¹³æ¿ä¸Šæ–¹
                
                // ç»˜åˆ¶å°çƒé˜´å½±
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(ballScreenX + 2, this.platformY + this.ballX * sin + 2, 12, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶å°çƒ
                const gradient = ctx.createRadialGradient(ballScreenX - 3, ballScreenY - 3, 0, ballScreenX, ballScreenY, 12);
                gradient.addColorStop(0, '#ff6b6b');
                gradient.addColorStop(1, '#c92a2a');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(ballScreenX, ballScreenY, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶å°çƒé«˜å…‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(ballScreenX - 3, ballScreenY - 3, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawTarget() {
                const ctx = this.ctx;
                
                // ç»˜åˆ¶ç›®æ ‡åŒºåŸŸ
                ctx.strokeStyle = 'rgba(56, 178, 172, 0.5)';
                ctx.fillStyle = 'rgba(56, 178, 172, 0.1)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                const targetRadius = 30;
                ctx.beginPath();
                ctx.arc(this.centerX, this.platformY - 15, targetRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.setLineDash([]);
                
                // ç»˜åˆ¶ç›®æ ‡ä¸­å¿ƒ
                ctx.fillStyle = '#38b2ac';
                ctx.beginPath();
                ctx.arc(this.centerX, this.platformY - 15, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ç®€å•çš„AIç®—æ³•ï¼ˆæ”¹è¿›çš„PIDæ§åˆ¶å™¨ + å­¦ä¹ æœºåˆ¶ï¼‰
        class BalanceAI {
            constructor() {
                this.lastAction = 0;
                this.memory = [];
                this.epsilon = 0.9; // æ¢ç´¢ç‡
                this.epsilonDecay = 0.995;
                this.epsilonMin = 0.1;
                this.learningRate = 0.1;
                
                // PIDå‚æ•°
                this.kp = 1.0; // æ¯”ä¾‹
                this.kd = 0.5; // å¾®åˆ†
                this.ki = 0.01; // ç§¯åˆ†
                
                this.lastError = 0;
                this.integral = 0;
                
                // Qè¡¨çš„ç®€åŒ–ç‰ˆæœ¬ï¼ˆçŠ¶æ€ç¦»æ•£åŒ–ï¼‰
                this.qTable = {};
                this.reset();
            }
            
            reset() {
                this.lastError = 0;
                this.integral = 0;
                this.epsilon = Math.max(this.epsilonMin, this.epsilon * this.epsilonDecay);
            }
            
            getAction(state) {
                // è·å–PIDæ¨èåŠ¨ä½œ
                const pidAction = this.getPIDAction(state);
                
                // epsilon-greedyç­–ç•¥
                if (Math.random() < this.epsilon) {
                    // æ¢ç´¢ï¼šéšæœºåŠ¨ä½œ
                    this.lastAction = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
                } else {
                    // åˆ©ç”¨ï¼šä½¿ç”¨PIDæˆ–å­¦ä¹ åˆ°çš„ç­–ç•¥
                    const stateKey = this.discretizeState(state);
                    const qValues = this.qTable[stateKey];
                    
                    if (qValues) {
                        // ä½¿ç”¨Qè¡¨
                        let bestAction = 0;
                        let bestValue = -Infinity;
                        for (let action = -1; action <= 1; action++) {
                            if (qValues[action] > bestValue) {
                                bestValue = qValues[action];
                                bestAction = action;
                            }
                        }
                        this.lastAction = bestAction;
                    } else {
                        // ä½¿ç”¨PIDæ§åˆ¶å™¨
                        this.lastAction = pidAction;
                    }
                }
                
                return this.lastAction;
            }
            
            getPIDAction(state) {
                const error = state.ballPosition; // æœŸæœ›ä½ç½®æ˜¯0
                const derivative = error - this.lastError;
                this.integral += error;
                
                // é™åˆ¶ç§¯åˆ†é¡¹é˜²æ­¢ç§¯åˆ†é¥±å’Œ
                this.integral = Math.max(-10, Math.min(10, this.integral));
                
                const output = this.kp * error + this.kd * derivative + this.ki * this.integral;
                
                this.lastError = error;
                
                // å°†è¾“å‡ºè½¬æ¢ä¸ºåŠ¨ä½œ
                if (output > 0.1) return 1;  // é¡ºæ—¶é’ˆ
                if (output < -0.1) return -1; // é€†æ—¶é’ˆ
                return 0; // ä¸åŠ¨
            }
            
            discretizeState(state) {
                // å°†è¿ç»­çŠ¶æ€ç¦»æ•£åŒ–ä¸ºå­—ç¬¦ä¸²é”®
                const pos = Math.round(state.ballPosition * 10) / 10;
                const vel = Math.round(state.ballVelocity * 10) / 10;
                const angle = Math.round(state.plateAngle * 10) / 10;
                return `${pos},${vel},${angle}`;
            }
            
            learn(state, action, reward, nextState, done) {
                const stateKey = this.discretizeState(state);
                const nextStateKey = this.discretizeState(nextState);
                
                // åˆå§‹åŒ–Qå€¼
                if (!this.qTable[stateKey]) {
                    this.qTable[stateKey] = {'-1': 0, '0': 0, '1': 0};
                }
                if (!this.qTable[nextStateKey]) {
                    this.qTable[nextStateKey] = {'-1': 0, '0': 0, '1': 0};
                }
                
                // Q-learningæ›´æ–°
                const currentQ = this.qTable[stateKey][action];
                let maxNextQ = -Infinity;
                for (let a = -1; a <= 1; a++) {
                    maxNextQ = Math.max(maxNextQ, this.qTable[nextStateKey][a]);
                }
                
                const target = reward + (done ? 0 : 0.95 * maxNextQ); // gamma = 0.95
                this.qTable[stateKey][action] += this.learningRate * (target - currentQ);
            }
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        let game;
        window.addEventListener('load', () => {
            game = new GameState();
        });
    </script>
</body>
</html>